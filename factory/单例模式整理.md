# 单例模式整理

| 单例名称                 | 定义                                                         | 优点                                                         | 缺点                                                         | 线程安全问题                                                 | 使用场景                                                     |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 饿汉式加载               | 类加载的时候就立即初始化，并且创建单例对象                   | 没有加任何额的锁、执行效率比较高，在用户体验上来说，比懒汉式更好 | 类加载的时候就初始化，不管你用还是不用，我都占着空间，浪费了内存，有可能占着茅坑不拉屎 | 绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题 | 单例对象较少的情况                                           |
| 简单懒汉式加载           | 在外部需要使用的时候才进行实例化                             |                                                              |                                                              | 存在线程安全隐患                                             |                                                              |
| 加锁懒汉式加载           |                                                              |                                                              | 用synchronized加锁，在线程数量比较多的情况下，如果CPU分配压力上升，会导致大批量线程出现阻塞，从而导致线程运行性能下降。 |                                                              |                                                              |
|                          |                                                              |                                                              |                                                              |                                                              |                                                              |
| 双重检查锁单例模式       | 1.分配内存给这个对象 2、初始化对象 3、设置lazy（引用）指向刚分配的内存地址 |                                                              |                                                              | 阻塞并不是基于整个LazySimpleSingleton 类的阻塞，而是在getInstance()方法内部阻塞，只要逻辑不是太复杂，对于调用者而言感知不到。 |                                                              |
| 静态内部类单例模式       | 兼顾饿汉式的内存浪费，也兼顾synchronized 性能问题            |                                                              |                                                              |                                                              |                                                              |
| 注册式单例（登记式单例） |                                                              |                                                              |                                                              |                                                              |                                                              |
| 容器缓存                 | ConcurrentHashMap                                            |                                                              |                                                              | 线程不安全                                                   | 容器式写法适用于创建实例非常多的情况，便于管理               |
| 枚举登记                 | 饿汉式单例的实现                                             | 序列化：枚举类型其实通过类名和Class 对象类找到一个唯一的枚举对象  反射式：在newInstance()方法中做了强制性的判断，如果修饰符是Modifier.ENUM 枚举类型，直接抛出异常 |                                                              |                                                              | 常量中去使用，常量不就是用来大家都能够共用      通常在通用API中使用 |

| 破坏方法 | 解决方案                  | 缺点                                           |
| -------- | ------------------------- | ---------------------------------------------- |
| 反射     | 添加检查异常抛出          |                                                |
| 序列化   | 增加对象readResolve()方法 | 增加内存开销；实际上实例化了两次，不过没有返回 |
|          |                           |                                                |

